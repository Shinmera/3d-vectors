#|
 This file is a part of 3d-vectors
 (c) 2016 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:cl-user)
(defpackage #:3d-vectors-test
  (:nicknames #:org.shirakumo.flare.vector.test)
  (:use #:cl #:prove #:3d-vectors))
(in-package #:org.shirakumo.flare.vector.test)

(defun ~= (a b)
  (<= (abs (- a b)) 0.0001))

(defmacro isv-type-eq-error (op)
  `(progn (is-error (,op (vec 1 2) (vec 1 2 3)) 'error)
          (is-error (,op (vec 1 2) (vec 1 2 3 4)) 'error)
          (is-error (,op (vec 1 2 3) (vec 1 2 3 4)) 'error)))

(defmacro isv (form x y &optional z w)
  `(is ,form (vec ,x ,y ,@(when z (list z)) ,@(when w (list w))) :test #'v=))

(defmacro isvt ((op a &optional b) x y z w)
  (typecase b
    (cons
     (destructuring-bind (a ax ay az aw) a
       (destructuring-bind (b bx by bz bw) b
         `(progn (isv (,op (,a ,ax ,ay) (,b ,bx ,by)) ,x ,y)
                 (isv (,op (,a ,ax ,ay ,az) (,b ,bx ,by ,bz)) ,x ,y ,z)
                 (isv (,op (,a ,ax ,ay ,az ,aw) (,b ,bx ,by ,bz ,bw)) ,x ,y ,z ,w)))))
    (null
     (destructuring-bind (a ax ay az aw) a
       `(progn (isv (,op (,a ,ax ,ay)) ,x ,y)
               (isv (,op (,a ,ax ,ay ,az)) ,x ,y ,z)
               (isv (,op (,a ,ax ,ay ,az ,aw)) ,x ,y ,z ,w))))
    (T
     (destructuring-bind (a ax ay az aw) a
       `(progn (isv (,op (,a ,ax ,ay) ,b) ,x ,y)
               (isv (,op (,a ,ax ,ay ,az) ,b) ,x ,y ,z)
               (isv (,op (,a ,ax ,ay ,az ,aw) ,b) ,x ,y ,z ,w))))))

(defmacro is= (a b)
  `(is ,a ,b :test #'=))

(defmacro is~ (a b)
  `(is ,a ,b :test #'~=))

(plan 7)

(subtest "Base struct"
  (is-type (vec2 1 2) 'vec2)
  (is-type (vec3 1 2 3) 'vec3)
  (is-type (vec4 1 2 3 4) 'vec4)
  (is-type (vec 1 2) 'vec2)
  (is-type (vec 1 2 3) 'vec3)
  (is-type (vec 1 2 3 4) 'vec4)
  (ok (vec2-p (vec2 1 2)))
  (ok (vec3-p (vec3 1 2 3)))
  (ok (vec4-p (vec4 1 2 3 4)))
  (is-type (vcopy (vec 1 2)) 'vec2)
  (is-type (vcopy (vec 1 2 3)) 'vec3)
  (is-type (vcopy (vec 1 2 3 4)) 'vec4)
  (is= 1 (vx (vec 1 2)))
  (is= 2 (vy (vec 1 2)))
  (is-error (vz (vec 1 2)) 'error)
  (is-error (vw (vec 1 2)) 'error)
  (is= 1 (vx (vec 1 2 3)))
  (is= 2 (vy (vec 1 2 3)))
  (is= 3 (vz (vec 1 2 3)))
  (is-error (vw (vec 1 2 3)) 'error)
  (is= 1 (vx (vec 1 2 3 4)))
  (is= 2 (vy (vec 1 2 3 4)))
  (is= 3 (vz (vec 1 2 3 4)))
  (is= 4 (vw (vec 1 2 3 4))))

(subtest "Comparators"
  (ok (v= (vec 1 2) (vec 1 2)))
  (ok (v= (vec 1 2 3) (vec 1 2 3)))
  (ok (v= (vec 1 2 3 4) (vec 1 2 3 4)))
  (ok (not (v= (vec 1 1) (vec 1 2))))
  (ok (not (v= (vec 1 1 1) (vec 1 2 3))))
  (ok (not (v= (vec 1 1 1 1) (vec 1 2 3 4))))
  (isv-type-eq-error v=)
  (ok (v/= (vec 2 2) (vec 1 2)))
  (ok (v/= (vec 2 2 3) (vec 1 2 3)))
  (ok (v/= (vec 2 2 3 4) (vec 1 2 3 4)))
  (ok (not (v/= (vec 1 2) (vec 1 2))))
  (ok (not (v/= (vec 1 2 3) (vec 1 2 3))))
  (ok (not (v/= (vec 1 2 3 4) (vec 1 2 3 4))))
  (isv-type-eq-error v/=)
  (ok (v< (vec 1 1) (vec 2 2)))
  (ok (v< (vec 1 1 1) (vec 2 2 2)))
  (ok (v< (vec 1 1 1 1) (vec 2 2 2 2)))
  (ok (not (v< (vec 1 1) (vec 1 1))))
  (ok (not (v< (vec 1 1 1) (vec 1 1 1))))
  (ok (not (v< (vec 1 1 1 1) (vec 1 1 1 1))))
  (isv-type-eq-error v<)
  (ok (v> (vec 2 2) (vec 1 1)))
  (ok (v> (vec 2 2 2) (vec 1 1 1)))
  (ok (v> (vec 2 2 2 2) (vec 1 1 1 1)))
  (ok (not (v> (vec 1 1) (vec 1 1))))
  (ok (not (v> (vec 1 1 1) (vec 1 1 1))))
  (ok (not (v> (vec 1 1 1 1) (vec 1 1 1 1))))
  (isv-type-eq-error v>)
  (ok (v<= (vec 1 1) (vec 2 2)))
  (ok (v<= (vec 1 1) (vec 1 1)))
  (ok (v<= (vec 1 1 1) (vec 2 2 2)))
  (ok (v<= (vec 1 1 1) (vec 1 1 1)))
  (ok (v<= (vec 1 1 1 1) (vec 2 2 2 2)))
  (ok (v<= (vec 1 1 1 1) (vec 1 1 1 1)))
  (ok (not (v<= (vec 2 2) (vec 1 1))))
  (ok (not (v<= (vec 2 2 2) (vec 1 1 1))))
  (ok (not (v<= (vec 2 2 2 2) (vec 1 1 1 1))))
  (isv-type-eq-error v<=)
  (ok (v>= (vec 2 2) (vec 1 1)))
  (ok (v>= (vec 1 1) (vec 1 1)))
  (ok (v>= (vec 2 2 2) (vec 1 1 1)))
  (ok (v>= (vec 1 1 1) (vec 1 1 1)))
  (ok (v>= (vec 2 2 2 2) (vec 1 1 1 1)))
  (ok (v>= (vec 1 1 1 1) (vec 1 1 1 1)))
  (ok (not (v>= (vec 1 1) (vec 2 2))))
  (ok (not (v>= (vec 1 1 1) (vec 2 2 2))))
  (ok (not (v>= (vec 1 1 1 1) (vec 2 2 2 2))))
  (isv-type-eq-error v>=))

(subtest "Constants"
  (isv +vx2+ 1 0)
  (isv +vy2+ 0 1)
  (isv +vx3+ 1 0 0)
  (isv +vy3+ 0 1 0)
  (isv +vz3+ 0 0 1)
  (isv +vx4+ 1 0 0 0)
  (isv +vy4+ 0 1 0 0)
  (isv +vz4+ 0 0 1 0)
  (isv +vw4+ 0 0 0 1)
  (isv +vx+ 1 0 0)
  (isv +vy+ 0 1 0)
  (isv +vz+ 0 0 1))

(subtest "Arithmetic"
  ;; FIXME: Tests for the modifying variants
  (isvt (v+ (vec 1 2 3 4)) 1 2 3 4)
  (isvt (v+ (vec 1 2 3 4) 2) 3 4 5 6)
  (isvt (v+ (vec 1 2 3 4) (vec 1 2 3 4)) 2 4 6 8)
  (isv-type-eq-error v+)
  (isv-type-eq-error nv+)
  (isvt (v- (vec 1 2 3 4)) -1 -2 -3 -4)
  (isvt (v- (vec 1 2 3 4) 2) -1 0 1 2)
  (isvt (v- (vec 1 2 3 4) (vec 1 2 3 4)) 0 0 0 0)
  (isv-type-eq-error v-)
  (isv-type-eq-error nv-)
  (isvt (v* (vec 1 2 3 4)) 1 2 3 4)
  (isvt (v* (vec 1 2 3 4) 2) 2 4 6 8)
  (isvt (v* (vec 1 2 3 4) (vec 1 2 3 4)) 1 4 9 16)
  (isv-type-eq-error v*)
  (isv-type-eq-error nv*)
  (isvt (v/ (vec 1 2 3 4)) 1 1/2 1/3 1/4)
  (isvt (v/ (vec 1 2 3 4) 2) 1/2 1 3/2 2)
  (isvt (v/ (vec 1 2 3 4) (vec 1 2 3 4)) 1 1 1 1)
  (isv-type-eq-error v/)
  (isv-type-eq-error nv/)
  (isvt (v1+ (vec 1 2 3 4)) 2 3 4 5)
  (isvt (v1- (vec 1 2 3 4)) 0 1 2 3))

(subtest "Vector Math"
  (is= (vlength (vec 1 0 0 0)) 1)
  (is= (vlength (vec 4 0 0 0)) 4)
  (is= (vlength (vec 1 2 3 4)) (sqrt (+ 1 4 9 16)))
  (is= (v. (vec 1 2 3 4) (vec 4 3 2 1)) (+ (* 1 4) (* 2 3) (* 3 2) (* 4 1)))
  (isv (vc (vec 1 2 3) (vec 3 2 1)) -4 8 -4)
  (isv (vrot (vec 1 2 3) (vec 0 1 0) (sin 360)) 3.0301156 2.0 0.90465444)
  (is~ (vlength (vunit (vec 1 2 3 4))) 1)
  (is~ (vlength (vscale (vec 1 2 3 4) 2)) 2)
  (isv (vabs (vec 1 -1 -2 2)) 1 1 2 2)
  (isv (vmod (vec 5 10 15 20) 10) 5 0 5 0)
  (isv (vclamp -1 (vec -2 0 2 3) 2) -1 0 2 2)
  (isv (vlimit (vec -2 -1 1 2) 1) -1 -1 1 1))

(subtest "Swizzling"
  ;; I'm not going to enumerate all possibilities, fuck that.
  (isv (vorder (vec 1 2 3 4) :y :y :y :y) 2 2 2 2)
  (isv (vorder (vec 1 2 3 4) :z) 3 0 0 0)
  (isv (vxx (vec 1 2 3 4)) 1 1)
  (isv (vxyz (vec 1 2 3 4)) 1 2 3)
  (isv (vyyy_ (vec 1 2 3 4)) 2 2 2 0))

(subtest "Modifiers"
  (let ((vec (vsetf (vec 1 2 3 4) 4 3 2 1)))
    (isv vec 4 3 2 1))
  (isv (vapply (vec 1 2 3 4) 1+) 2 3 4 5)
  (let ((vec (vapplyf (vec 1 2 3 4) 1-)))
    (isv vec 0 1 2 3))
  (let ((vec (vincf (vec 1 2 3 4) 5)))
    (isv vec 6 7 8 9))
  (let ((vec (vdecf (vec 1 2 3 4) 2)))
    (isv vec -1 0 1 2)))

(finalize)
